<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="Owl Dawn">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="/img/amiya.jpg">
    <meta property="twitter:image" content="/img/amiya.jpg" />
    

    
    <meta name="title" content="redis" />
    <meta property="og:title" content="redis" />
    <meta property="twitter:title" content="redis" />
    

    
    <meta name="description" content="OwlDawn，程序员, 动漫爱好者 | 这里是 OwlDawn 的博客，与你一起发现更大的世界。">
    <meta property="og:description" content="OwlDawn，程序员, 动漫爱好者 | 这里是 OwlDawn 的博客，与你一起发现更大的世界。" />
    <meta property="twitter:description" content="OwlDawn，程序员, 动漫爱好者 | 这里是 OwlDawn 的博客，与你一起发现更大的世界。" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="OwlDawn, OwlDawn的博客, 个人网站, 互联网, Web, 云原生, Kubernetes, 微服务, Microservice">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>redis | OwlDawn的博客 | OwlDawn Blog</title>

    <link rel="canonical" href="/redis/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link href="https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css" rel="stylesheet" type="text/css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="/js/lazysizes.min.js"></script>

    
    

</head>






<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Owl Dawn</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                        <li>
                            <a href="/categories/ceph">ceph</a>
                        </li>
                        
                        <li>
                            <a href="/categories/cgroup">cgroup</a>
                        </li>
                        
                        <li>
                            <a href="/categories/coroutine">coroutine</a>
                        </li>
                        
                        <li>
                            <a href="/categories/cpp">cpp</a>
                        </li>
                        
                        <li>
                            <a href="/categories/leveldb">leveldb</a>
                        </li>
                        
                        <li>
                            <a href="/categories/linux">linux</a>
                        </li>
                        
                        <li>
                            <a href="/categories/raft">raft</a>
                        </li>
                        
                        <li>
                            <a href="/categories/redis">redis</a>
                        </li>
                        
                        <li>
                            <a href="/categories/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97">无锁队列</a>
                        </li>
                        
                    
                    
		    
                        <li><a href="/archive/">ARCHIVE</a></li>
                    
                        <li><a href="/notes/">NOTES</a></li>
                    
                        <li><a href="/about/">ABOUT</a></li>
                    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/amiya.jpg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/redis" title="redis">
                            redis
                        </a>
                        
                    </div>
                    <h1>redis</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                OwlDawn
                             
                            on 
                            Monday, February 27, 2023
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h1 id="redis_note">Redis_note</h1>
<p>6.0.9 版本源码</p>
<h2 id="数据结构">数据结构</h2>
<h3 id="sds">SDS</h3>
<p><strong>定义结构：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">__attribute__</span> ((__packed__)) sdshdr64 {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">uint64_t</span> len; <span style="color:#6272a4">/* used 已使用的字节长度 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">uint64_t</span> alloc; <span style="color:#6272a4">/* excluding the header and null terminator */</span><span style="color:#6272a4">//不包括头部和&#39;\0&#39;截止符
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> flags; <span style="color:#6272a4">/* 3 lsb of type, 5 unused bits */</span> <span style="color:#6272a4">//只有前3位被使用，用作标志SDS_TYPE_64 或 32 或 16 等等
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//部分语言技巧
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>sds;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))		</span><span style="color:#6272a4">// 将char*转换为 sdshdr 结构，函数传参使用 char*,在函数内部通过这个宏转换为 sdshdr
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// T 为8，16，32，64的选择
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> flags <span style="color:#ff79c6">=</span> s[<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>]; <span style="color:#6272a4">// 可以取出 flag
</span></span></span></code></pre></div><p><strong>字符串扩展内存不够时，分配策略：</strong></p>
<p>修改长度后，如果长度 len 小于 1M，将分配相同 len 的未使用空间，否则分配1M的未使用空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">#define SDS_MAX_PREALLOC (1024*1024)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>newlen <span style="color:#ff79c6">=</span> (len<span style="color:#ff79c6">+</span>addlen);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">if</span> (newlen <span style="color:#ff79c6">&lt;</span> SDS_MAX_PREALLOC)
</span></span><span style="display:flex;"><span>    newlen <span style="color:#ff79c6">*=</span> <span style="color:#bd93f9">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">else</span>
</span></span><span style="display:flex;"><span>    newlen <span style="color:#ff79c6">+=</span> SDS_MAX_PREALLOC;
</span></span></code></pre></div><p>缩短字符串后不会释放空间。</p>
<h3 id="链表">链表</h3>
<p>结构定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> listNode {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> listNode <span style="color:#ff79c6">*</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> listNode <span style="color:#ff79c6">*</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>value;
</span></span><span style="display:flex;"><span>} listNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> listIter {                <span style="color:#6272a4">// 迭代器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    listNode <span style="color:#ff79c6">*</span>next;                      <span style="color:#6272a4">// 当前迭代到的节点
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> direction;                       <span style="color:#6272a4">// 迭代方向
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} listIter;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> list {
</span></span><span style="display:flex;"><span>    listNode <span style="color:#ff79c6">*</span>head;
</span></span><span style="display:flex;"><span>    listNode <span style="color:#ff79c6">*</span>tail;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>dup)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>ptr);              <span style="color:#6272a4">// 节点值复制函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>free)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>ptr);              <span style="color:#6272a4">// 节点值释放函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>match)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>ptr, <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key);   <span style="color:#6272a4">// 节点值对比函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> len;                    <span style="color:#6272a4">// 节点数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} list;
</span></span></code></pre></div><h3 id="字典">字典</h3>
<p><strong>哈希表结构定义：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">/* This is our hash table structure. Every dictionary has two of this as we
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"> * implement incremental rehashing, for the old to the new table. */</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> dictht {
</span></span><span style="display:flex;"><span>    dictEntry <span style="color:#ff79c6">**</span>table;                  <span style="color:#6272a4">// 哈希表数组
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> size;                 <span style="color:#6272a4">// 哈希表大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> sizemask;             <span style="color:#6272a4">// 哈希表掩码，用于计算索引值，为 size - 1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> used;                 <span style="color:#6272a4">// 该哈希表已有节点的数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} dictht;
</span></span></code></pre></div><p>每个字典都使用两个哈希表，从而实现渐进式 rehash</p>
<p><strong>哈希表节点</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> dictEntry {              <span style="color:#6272a4">// 哈希表节点
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key;                          <span style="color:#6272a4">// 键
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">union</span> {                             <span style="color:#6272a4">// 值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>val;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">uint64_t</span> u64;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">int64_t</span> s64;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">double</span> d;
</span></span><span style="display:flex;"><span>    } v;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> dictEntry <span style="color:#ff79c6">*</span>next;      <span style="color:#6272a4">// 指向下一个哈希表节点，形成链表
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} dictEntry;
</span></span></code></pre></div><p><strong>字典结构定义：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> dict {
</span></span><span style="display:flex;"><span>    dictType <span style="color:#ff79c6">*</span>type;             <span style="color:#6272a4">// 类型特定函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata;             <span style="color:#6272a4">// 私有数据
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    dictht ht[<span style="color:#bd93f9">2</span>];               <span style="color:#6272a4">// 哈希表
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">long</span> rehashidx;     <span style="color:#6272a4">/* rehash索引，rehash不在进行时为-1 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> iterators; <span style="color:#6272a4">/* 目前正在运行的安全迭代器的数量 */</span>
</span></span><span style="display:flex;"><span>} dict;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> dictType {          <span style="color:#6272a4">// 字典类型特定函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">uint64_t</span> (<span style="color:#ff79c6">*</span>hashFunction)(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key);          <span style="color:#6272a4">// 计算哈希值的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>keyDup)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key);   <span style="color:#6272a4">// 复制键的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>valDup)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>obj);   <span style="color:#6272a4">// 复制值的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>keyCompare)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key1, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key2);  <span style="color:#6272a4">// 对比键的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>keyDestructor)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata, <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key);   <span style="color:#6272a4">// 销毁键的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>valDestructor)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata, <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>obj);   <span style="color:#6272a4">// 销毁值的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} dictType;
</span></span></code></pre></div><p><code>ht[1]</code>哈希表只会在<code>ht[0]</code>哈希表进行 rehash 时使用</p>
<p><strong>迭代器结构：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">/* If safe is set to 1 this is a safe iterator, that means, you can call
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"> * dictAdd, dictFind, and other functions against the dictionary even while
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"> * iterating. Otherwise it is a non safe iterator, and only dictNext()
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"> * should be called while iterating. */</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> dictIterator {
</span></span><span style="display:flex;"><span>    dict <span style="color:#ff79c6">*</span>d;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">long</span> index;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> table, safe;
</span></span><span style="display:flex;"><span>    dictEntry <span style="color:#ff79c6">*</span>entry, <span style="color:#ff79c6">*</span>nextEntry;
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">/* unsafe iterator fingerprint for misuse detection. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">long</span> <span style="color:#8be9fd">long</span> fingerprint;
</span></span><span style="display:flex;"><span>} dictIterator;
</span></span></code></pre></div><p>语言技巧</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">#define dictSetVal(d, entry, _val_) do { \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">    if ((d)-&gt;type-&gt;valDup) \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">        (entry)-&gt;v.val = (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">    else \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">        (entry)-&gt;v.val = (_val_); \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">} while(0)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span><span style="color:#6272a4">// 使用 do{}while(0) 避免宏替换后代码被展开
</span></span></span></code></pre></div><p><strong>哈希算法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>hash <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">dictHashKey</span>(d,key);
</span></span><span style="display:flex;"><span>idx <span style="color:#ff79c6">=</span> hash <span style="color:#ff79c6">&amp;</span> d<span style="color:#ff79c6">-&gt;</span>ht[table].sizemask;  <span style="color:#6272a4">// 相当于 hash % size，将 hash 分布到 size 大小
</span></span></span></code></pre></div><p><strong>rehash</strong></p>
<ol>
<li>为<code>ht[1]</code>分配空间
<ul>
<li>扩展：大小为第一个大于等于 <code>ht[0].used * 2</code>的 2 的 n 次幂</li>
<li>收缩：大小为第一个大于等于 <code>ht[0].used</code>的 2 的 n 次幂</li>
</ul>
</li>
<li>将<code>ht[0]</code>包含的键值对 rehash 到 <code>ht[1]</code>上（重新计算哈希值与索引值）</li>
<li>释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新建一个空的哈希表</li>
</ol>
<p><strong>渐进式rehash</strong></p>
<p>将<code>rehashidx</code>设置为0，表示 rehash 开始</p>
<p>每次对字典执行操作时，程序会顺带将<code>ht[0]</code>在<code>rehashidx</code>上的键值对 rehash 到<code>ht[1]</code>，完成后+1</p>
<p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。例如查找某个键，程序会先在ht[0]中查找，如果找不到，就再去ht[1]中查找。</p>
<h3 id="整数集合">整数集合</h3>
<p>当一个集合<strong>只包含整数值元素</strong>，且这个集合的元素<strong>数目不多</strong>时，就会使用整数集合作为集合键的底层实现</p>
<p><strong>结构定义：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> intset {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">uint32_t</span> encoding;  <span style="color:#6272a4">// 编码方式
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">uint32_t</span> length;    <span style="color:#6272a4">// 集合包含的元素数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int8_t</span> contents[];  <span style="color:#6272a4">// 保存元素的数组，真正类型取决于 encoding 的值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} intset;
</span></span></code></pre></div><p><strong>升级：</strong></p>
<p>如 当向一个底层为 int16_t 数组的整数集合添加一个 int64_t 类型的整数值时，整数集合已有的所有元素都会转型为 int64_t 。</p>
<ol>
<li>重新分配空间</li>
<li>转换旧元素类型，放在正确位置上</li>
<li>添加新元素</li>
</ol>
<p><strong>不支持降级</strong></p>
<h3 id="压缩列表">压缩列表</h3>
<p><strong>储存结构：</strong></p>
<p><code>&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td></td>
<td>记录整个压缩列表占用字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td></td>
<td>记录压缩列表尾节点距离压缩列表起始地址有多少字节</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td></td>
<td>记录压缩列表包含的节点数量<br>When there are more than 2^16-2 entries, this value is set to 2^16-1 and we need to traverse the entire list to know how many items it holds.</td>
</tr>
<tr>
<td>entry</td>
<td></td>
<td></td>
<td>节点</td>
</tr>
<tr>
<td>zlend</td>
<td></td>
<td></td>
<td>特殊值 0xFF 标记压缩列表的末端</td>
</tr>
</tbody>
</table>
<p><strong>entry</strong>:</p>
<p><code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></p>
<p><strong>prevlen:</strong></p>
<p>记录压缩列表前一个节点长度</p>
<p>见书</p>
<p><strong>连锁更新</strong></p>
<p>由于在插入长节点，使<code>prevlen</code>增加长度，从而引发的连锁更新</p>
<p>删除节点也会引发连锁更新</p>
<h3 id="quicklist">QuickList</h3>
<p>
  <img src="pic/20170418155917948.png" alt="">

</p>
<p><strong>结构定义</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> quicklist {
</span></span><span style="display:flex;"><span>    quicklistNode <span style="color:#ff79c6">*</span>head;
</span></span><span style="display:flex;"><span>    quicklistNode <span style="color:#ff79c6">*</span>tail;
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//ziplist中的entry节点计数器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> count;        <span style="color:#6272a4">/* total count of all entries in all ziplists */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//quicklist的quicklistNode节点计数器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> len;          <span style="color:#6272a4">/* number of quicklistNodes */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 保存ziplist的大小，配置文件设定，占16bits
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">fill</span> : QL_FILL_BITS;              <span style="color:#6272a4">/* fill factor for individual nodes */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//保存压缩程度值，配置文件设定，占16bits，0表示不压缩
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">compress</span> : QL_COMP_BITS; <span style="color:#6272a4">/* depth of end nodes not to compress;0=off */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">bookmark_count</span>: QL_BM_BITS;
</span></span><span style="display:flex;"><span>    quicklistBookmark bookmarks[];
</span></span><span style="display:flex;"><span>} quicklist;
</span></span></code></pre></div><p><strong>quicklist节点结构</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> quicklistNode {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> quicklistNode <span style="color:#ff79c6">*</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> quicklistNode <span style="color:#ff79c6">*</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//不设置压缩数据参数recompress时指向一个ziplist结构
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//设置压缩数据参数recompress指向quicklistLZF结构
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>zl;
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//压缩列表ziplist的总长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> sz;             <span style="color:#6272a4">/* ziplist size in bytes */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//ziplist中包的节点数，占16 bits长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">count</span> : <span style="color:#bd93f9">16</span>;     <span style="color:#6272a4">/* count of items in ziplist */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//表示是否采用了LZF压缩算法压缩quicklist节点，1表示压缩过，2表示没压缩，占2 bits长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">encoding</span> : <span style="color:#bd93f9">2</span>;   <span style="color:#6272a4">/* RAW==1 or LZF==2 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//表示一个quicklistNode节点是否采用ziplist结构保存数据，2表示压缩了，1表示没压缩，默认是2，占2bits长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">container</span> : <span style="color:#bd93f9">2</span>;  <span style="color:#6272a4">/* NONE==1 or ZIPLIST==2 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//标记quicklist节点的ziplist之前是否被解压缩过，占1bit长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//如果recompress为1，则等待被再次压缩
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">recompress</span> : <span style="color:#bd93f9">1</span>; <span style="color:#6272a4">/* was this node previous compressed? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//测试时使用
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">attempted_compress</span> : <span style="color:#bd93f9">1</span>; <span style="color:#6272a4">/* node can&#39;t compress; too small */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//额外扩展位，占10bits长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">extra</span> : <span style="color:#bd93f9">10</span>; <span style="color:#6272a4">/* more bits to steal for future usage */</span>
</span></span><span style="display:flex;"><span>} quicklistNode;
</span></span></code></pre></div><p><strong>压缩过的ziplist结构—quicklistLZF</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> quicklistLZF {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//表示被LZF算法压缩后的ziplist的大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> sz; <span style="color:#6272a4">/* LZF size in bytes*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//保存压缩后的ziplist的数组，柔性数组
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">char</span> compressed[];
</span></span><span style="display:flex;"><span>} quicklistLZF;
</span></span></code></pre></div><p><strong>管理ziplist信息的结构quicklistEntry</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">//管理quicklist中quicklistNode节点中ziplist信息的结构
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> quicklistEntry {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> quicklist <span style="color:#ff79c6">*</span>quicklist;   <span style="color:#6272a4">//指向所属的quicklist的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    quicklistNode <span style="color:#ff79c6">*</span>node;          <span style="color:#6272a4">//指向所属的quicklistNode节点的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>zi;            <span style="color:#6272a4">//指向当前ziplist结构的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>value;         <span style="color:#6272a4">//指向当前ziplist结构的字符串vlaue成员
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">long</span> <span style="color:#8be9fd">long</span> longval;            <span style="color:#6272a4">//指向当前ziplist结构的整数value成员
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> sz;              <span style="color:#6272a4">//保存当前ziplist结构的字节数大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> offset;                   <span style="color:#6272a4">//保存相对ziplist的偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} quicklistEntry;
</span></span></code></pre></div><p><strong>迭代器</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">//quicklist的迭代器结构
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> quicklistIter {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> quicklist <span style="color:#ff79c6">*</span>quicklist;   <span style="color:#6272a4">//指向所属的quicklist的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    quicklistNode <span style="color:#ff79c6">*</span>current;       <span style="color:#6272a4">//指向当前迭代的quicklist节点的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>zi;            <span style="color:#6272a4">//指向当前quicklist节点中迭代的ziplist
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">long</span> offset;                  <span style="color:#6272a4">//当前ziplist结构中的偏移量      /* offset in current ziplist */
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> direction;                <span style="color:#6272a4">//迭代方向
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} quicklistIter;
</span></span></code></pre></div><p><strong>压缩深度</strong></p>
<p>quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数list-compress-depth决定。</p>
<p>为了支持快速的 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。</p>
<p>如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p>
<p><strong>插入</strong></p>
<p>以选择在头部或者尾部进行插入( <code>quicklistPushHead</code> 和 <code>quicklistPushTail </code>)，而不管是在头部还是尾部插入数据，都包含两种情况：</p>
<ul>
<li>如果头节点（或尾节点）上ziplist大小没有超过限制（即 <code>_quicklistNodeAllowInsert</code> 返回1），那么新数据被直接插入到ziplist中（调用<code>ziplistPush</code>）。</li>
<li>如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到 quicklist 双向链表中。</li>
</ul>
<p>也可以从任意指定的位置插入。<code>quicklistInsertAfter</code>和<code>quicklistInsertBefore</code>就是分别在指定位置后面和前面插入数据项。这种在任意指定位置插入数据的操作，要比在头部和尾部的进行插入要复杂一些。</p>
<ul>
<li>当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；</li>
<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；</li>
<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。</li>
<li>对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。</li>
</ul>
<h2 id="对象">对象</h2>
<p>结构定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">#define LRU_BITS 24
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> redisObject {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd;font-style:italic">type</span>:<span style="color:#bd93f9">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd;font-style:italic">encoding</span>:<span style="color:#bd93f9">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd;font-style:italic">lru</span>:LRU_BITS; <span style="color:#6272a4">/* LRU time (relative to global lru_clock) or
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">                            * LFU data (least significant 8 bits frequency
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">                            * and most significant 16 bits access time). */</span>
</span></span><span style="display:flex;"><span>                           <span style="color:#6272a4">// 最后一次被命令访问时间
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> refcount;          <span style="color:#6272a4">// 引用计数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>ptr;             <span style="color:#6272a4">// 指向底层实现数据结构
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} robj;
</span></span></code></pre></div><h4 id="字符串对象">字符串对象</h4>
<ul>
<li>
<p>int</p>
</li>
<li>
<p>raw</p>
</li>
<li>
<p>embstr  <strong>只读</strong> 任何修改命令都将其转为raw</p>
<p>调用一次内存分配函数创建 redisObject 结构和 sdshdr 结构，只需一次内存分配次数和一次内存释放次数。</p>
<p>只读，任何修改命令将转换为raw</p>
</li>
</ul>
<h4 id="列表对象">列表对象</h4>
<p>redis3.2之后使用quicklist代替了ziplist和linkedlist</p>
<h4 id="哈希对象">哈希对象</h4>
<ul>
<li>
<p>ziplist</p>
<p>同一键值对的两个节点紧挨在一起，键在前，值在后，不同键值对按添加顺序排列</p>
</li>
<li>
<p>hashtable</p>
<p>对象的每个键值对都是用一个字典键值对来保存，每个键和每个值都是一个字符串对象</p>
</li>
</ul>
<h4 id="集合对象">集合对象</h4>
<p>只存储不重复元素，无序方式，而列表对象可存储重复元素，先后顺序</p>
<ul>
<li>
<p>intset</p>
<p>当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</p>
</li>
<li>
<p>hashtable</p>
</li>
</ul>
<h4 id="有序集合对象">有序集合对象</h4>
<p>相比于集合类型多了一个排序属性 score（分值）</p>
<ul>
<li>
<p>ziplist</p>
</li>
<li>
<p>skiplist</p>
<p>同时使用跳跃表和字典实现，字典根据键找分值快，跳跃表根据分值找键快</p>
</li>
</ul>
<h2 id="数据库">数据库</h2>
<p>服务区每个数据库都有redisDb结构表示，dict字典保存着数据库的所以键值对，每个<strong>键为字符串对象，值为任意Redis对象</strong></p>
<h3 id="过期键删除策略">过期键删除策略</h3>
<ul>
<li>
<p><strong>定时删除：</strong></p>
<p>在设置键的过期时间的同时，创建一个定时器（timer）,让定时器在键的过期时间来临时，立即对执行对键的删除操作。
定时删除策略<strong>对内存较为友好，但是对CPU不友好</strong>。</p>
</li>
<li>
<p><strong>惰性删除：</strong></p>
<p>放任键过期不管，每次从键空间中取得键时，都检查取得的键是否过期，如果过期就删除该键，没有过期就返回该键。</p>
<p><strong>对CPU较为友好，对内存较为不友好</strong>。如果数据库中有很多的过期键，但是却永远不会被访问到，那么这可以看做是一种内存泄露。比如日志文件</p>
</li>
<li>
<p><strong>定期删除：</strong></p>
<p>每隔一段时间对数据库进行一次检查，删除过期键。<strong>折中</strong></p>
</li>
</ul>
<p><strong>==Redis 采用惰性删除  + 定期删除==</strong>。采用定期删除和惰性删除，仍然会有部分过期键没有被清除，所以需要用到内存淘汰机制。</p>
<h3 id="内存淘汰机制">内存淘汰机制</h3>
<ul>
<li>
<p>volatile-LRU</p>
<p>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</p>
</li>
<li>
<p>LFU</p>
</li>
<li>
<p>volatile-random</p>
<p>从已设置过期时间的数据集中任意选择数据淘汰</p>
</li>
<li>
<p>volatile-TTL</p>
<p>从已设置过期时间的数据集中挑选将要过期的数据淘汰</p>
</li>
<li>
<p>allkeys-LRU</p>
<p>从数据集中挑选最近最少使用的数据淘汰</p>
</li>
<li>
<p>no-enviction</p>
<p>禁止驱逐数据</p>
</li>
</ul>
<h3 id="rdb"><strong>RDB</strong></h3>
<p>记录的是<strong>某一时刻的数据</strong>，而不是操作</p>
<p><strong>子线程写入 + 启动时自动载入</strong></p>
<ul>
<li>将某个时间点的所有数据都存放到硬盘上。</li>
<li>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</li>
<li>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</li>
<li>如果数据量很大，保存快照的时间会很长。</li>
</ul>
<p><code>SAVE</code> 命令与 <code>BGSAVE</code> 命令用于生成 RDB 文件</p>
<p>保存时，过期键不会保存入新创建的RDB文件中</p>
<ul>
<li>主服务器模式：启动载入时过期键会被忽略</li>
<li>从服务器模式：所有键都会载入，从服务器数据会被清空</li>
</ul>
<p>服务器启动时自动载入RDB文件。服务器优先使用AOF文件还原数据库状态，AOF关闭时才使用RDB</p>
<p>服务器载入RDB文件期间处于阻塞状态</p>
<h3 id="aof"><strong>AOF</strong></h3>
<p>过期键被删除时AOF文件追加一条DEL命令</p>
<p>过期键不会保存到重写的AOF文件中</p>
<p>复制模式下，主服务器删除一个过期键，则同时通知从服务器删除，向从服务器发送DEL命令。</p>
<p>访问主服务器的过期键，会被删除，访问从服务器的过期键，能够访问</p>
<p>服务器appendfsync的值直接决定AOF持久化功能的效率和安全性</p>
<ul>
<li>Always：同步写回，每个写命令执行完立马同步将日志写回磁盘，<strong>最慢</strong></li>
<li>Everysec：每秒写回，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li>
<li>No：操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。性能最好，但是丢失数据多</li>
</ul>
<p><strong>AOF重写</strong></p>
<p>原理：首先从数据库读取现有键值，用一条命令记录键值，代替之前的多条冗余命令</p>
<p>使用==<strong>子进程</strong>==而非线程，这样重写期间，服务器进程（父进程）可以继续处理命令</p>
<p>完成后向父进程发送信号，将AOF重写缓冲区的内容写入新AOF缓冲区并替换</p>
<h4 id="事件">事件</h4>
<p><strong>文件事件</strong></p>
<p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p>
<p>
  <img src="pic/2.png" alt="">

</p>
<p><strong>时间事件</strong></p>
<p>所有时间事件都放在一个<strong>无序列表</strong>中</p>
<ul>
<li>定时事件</li>
<li>周期事件</li>
</ul>
<p>
  <img src="pic/1.png" alt="">

</p>
<p>对时间事件与文件事件的处理都是<strong>同步、有序、原子</strong>地执行，事件间不会抢占</p>
<h3 id="集群">集群</h3>
<p><code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 让 node 节点与 ip 和 port 指定的节点进行握手，握手成功时将指定的节点添加进当前所在集群</p>
<p><code>CLUSTER ADDSLOTS &lt;slot&gt; [slot ...]</code>将一个或多个槽给节点负责</p>
<p>当客户端向节点发送与数据库键有关的命令时，节点会计算键属于哪个槽，检查这个槽是否指派给自己，否则返回MOVED错误，指引客户端至正确节点，并重复步骤。</p>
<p><code>CLUSTER KEYSLOT &lt;key&gt;</code> 查看给定键属于哪个槽</p>
<p>重新分片操作可以在线进行，并可继续处理命令请求</p>
<h3 id="主从复制">主从复制</h3>
<p>作用：</p>
<ul>
<li>数据冗余：实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>数据恢复：当主节点出现问题，由从节点提供服务，实现快速的故障恢复。（服务的冗余）</li>
<li>负载均衡：主从复制的基础上，配合读写分离，有主节点提供写服务，从节点提供读服务。尤其写少读多的场景</li>
<li>高可用：是哨兵和集群能够实施的基础</li>
</ul>
<p>流程：</p>
<ol>
<li>设置主节点的地址和端口</li>
<li>建立套接字连接</li>
<li>发送PING命令</li>
<li>权限验证</li>
<li>同步</li>
<li>命令传播</li>
</ol>
<h4 id="同步">同步</h4>
<p>从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步</p>
<p><strong>全量复制</strong></p>
<p>用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</p>
<ol>
<li>从节点或主节点判断无法进行部分复制</li>
<li>主节点 fork 子进程执行 BGSave，在后台生成 RDB 文件，并使用一个缓冲区（复制缓冲区）记录从现在开始执行的写命令</li>
<li>主节点将 RDB 文件发送给从节点。从节点清除自己的旧数据，载入接收的 RDB 文件，将数据库状态更新至对应状态</li>
<li>主节点将复制缓冲区中的所有写命令发送给从节点，从节点执行写命令，更新状态</li>
<li>如果从节点开启了 AOF，会触发 bgRewriteAof，保证 AOF 文件更新至主节点的最新状态</li>
</ol>
<p>重型操作，消耗 CPU、内存、硬盘 IO，消耗主从节点的带宽；从节点载入新 RDB 文件的过程是阻塞的，无法响应客户端命令</p>
<p><strong>部分复制</strong></p>
<p>用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点</p>
<ul>
<li>
<p><strong>复制偏移量</strong>：主从节点分别维护一个复制偏移量 offset：主节点每次向从节点同步了 n 字节数据后，将修改自己的复制偏移量 offset+N；从节点同步后也会修改。如果二者 offset 不同，则根据两个 offset 找到从节点缺少的数据</p>
</li>
<li>
<p><strong>复制积压缓冲区</strong>：主节点内部维护一个<strong>固定长度的、先进先出(FIFO)队列</strong> 作为复制积压缓冲区，命令传播时，不仅会将写命令同步到从节点，还会将写命令写入复制积压缓冲区。</p>
<ul>
<li>由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。因此，<strong>当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</strong></li>
<li>从节点将 offset 发送给主节点后，主节点根据 offset 和缓冲区大小决定能否执行部分复制：</li>
</ul>
</li>
<li>
<p><strong>服务器运行ID (runid)</strong>：每个 Redis 节点，都有其运行 ID，运行 ID 由节点在启动时自动生成，主节点会将自己的运行 ID 发送给从节点，从节点会将主节点的运行 ID 存起来。 从节点 Redis 断开重连的时候，就是根据运行 ID 来判断同步的进度：</p>
<ul>
<li>如果从节点保存的 runid 与主节点现在的 runid 相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制</li>
<li>不同，说明从节点在断线前同步的 Redis 节点并不是当前的主节点，只能进行全量复制。</li>
</ul>
</li>
</ul>
<h4 id="命令传播">命令传播</h4>
<p>主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p>
<p><strong>repl-disable-tcp-nodelay</strong></p>
<ul>
<li>yes：合并小的 tcp 包从而节省带宽，但是增加同步延迟</li>
<li>no：master 会立即发送同步数据</li>
</ul>
<p>一般系统对数据不一致容忍度较高，且主从节点网络状态不好时采用 yes</p>
<p>心跳检测机制会定时向主服务发送消息，保证主从服务器一直处于连接状态</p>
<h3 id="哨兵">哨兵</h3>
<p>作用</p>
<ul>
<li><strong>监控（Monitoring）</strong>：持续监控 Redis 主节点、从节点是否处于预期的工作状态。</li>
<li><strong>通知（Notification）</strong>：哨兵可以把 Redis 实例的运行故障信息通过 API 通知监控系统或者其他应用程序。</li>
<li><strong>自动故障恢复（Automatic failover）</strong>：当主节点运行故障时，哨兵会启动自动故障恢复流程：某个从节点会升级为主节点，其他从节点会使用新的主节点进行主从复制，通知客户端使用新的主节点进行。</li>
<li><strong>配置中心（Configuration provider）</strong>：哨兵可以作为客户端服务发现的授权源，客户端连接到哨兵请求给定服务的 Redis 主节点地址。如果发生故障转移，哨兵会通知新的地址。这里要注意：哨兵并不是 Redis 代理，只是为客户端提供了 Redis 主从节点的地址信息。</li>
</ul>
<p>哨兵模式是天然的分布式系统，主节点的系统故障是在多个实例共同认可的情况下完成的；即使不是所有的哨兵实例都正常运行哨兵集群也能正常工作</p>
<h4 id="节点发现">节点发现</h4>
<p>哨兵节点每隔 10s（故障转移时每隔 1s）向主从节点发送 INFO 命令，以此获取主从节点的信息。第一次哨兵仅知道 主节点 信息，通过对主节点执行 INFO 可以获取其从节点列表</p>
<ul>
<li><code>INFO</code> 命令目标是从节点：哨兵从返回信息中获取从节点所属最新主节点 ip 和 port，如果与历史记录不一致，则执行更新；获取从节点的优先级、复制偏移量以及与主节点的链接状态并更新</li>
<li><code>INFO</code> 命令目标是主节点：获取从机列表，新增则将其加入监控列表</li>
<li>记录节点的 runID</li>
<li>节点的角色发生变化，哨兵会记录节点新的角色以及上报时间。</li>
</ul>
<p><strong>哨兵们通过发布订阅机制，通过一个约定好的通道（channel）发布、订阅 hello 信息进行通信</strong></p>
<h4 id="故障检测">故障检测</h4>
<p>通过 <code>PING</code> 命令实现对主从节点的故障检测。</p>
<p><strong>主管宕机</strong></p>
<p>一个哨兵实例通过检测发现某个主节点发生故障的一种状态</p>
<p><strong>客观宕机</strong></p>
<p>哨兵检测到某个主节点发生故障，通过命令 <code>SENTINEL is-master-down-by-addr</code> 与其他哨兵协商，在指定时间内收到指定数量的其他哨兵的确认反馈时的一种状态</p>
<h4 id="故障迁移">故障迁移</h4>
<p>过滤网络状态不好的节点，依次考察 <strong>优先级、复制进度、id 号</strong></p>
<ul>
<li>优先级：slave-priority 配置项，可以给从节点设置优先级。每一台从节点的服务器配置不一定是相同的，我们可以根据服务器性能配置来设置从节点的优先级。</li>
<li>复制进度，选取复制进度靠前的</li>
<li>id 号，ID 号小的节点胜出</li>
</ul>
<h4 id="sentinel-leader选举">Sentinel Leader选举</h4>
<p>选取 哨兵 leader 节点进行主从故障转移</p>
<p>raft</p>
<h3 id="集群-1">集群</h3>
<p>redis cluster 是一种服务器 sharding 技术，3.0 开始提供</p>
<p>对于哨兵模式，已经实现高可用，读写分离，但是每台 redis 服务器都存储相同的数据，浪费内存</p>
<p>引入哈希槽（hash slot），通过 CRC16 校验后对哈希槽个数取模来决定放置在哪个槽</p>
<p>与哨兵模式区别</p>
<ul>
<li>哨兵模式监控权交给了哨兵系统，集群模式中是工作节点自己做监控</li>
<li>哨兵模式发起选举是选举一个leader哨兵节点来处理故障转移，集群模式是在从节点中选举一个新的主节点，来处理故障的转移</li>
</ul>
<h2 id="缓存穿透击穿雪崩">缓存穿透、击穿、雪崩</h2>
<h3 id="缓存穿透">缓存穿透</h3>
<p>缓存和数据库中都没有的数据，用户不断发起请求，导致这个不存在的数据每次请求都要到存储层查询，失去了缓存的意义</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>接口层增加校验，如用户鉴权校验、ID 做基础校验、id &lt;= 0  的直接拦截</li>
<li>用缓存取不到的数据，在数据库中也没有渠道，这是可以将 key-value 写为 key-null，缓存有效时间可以设置短一些，防止攻击用户反复用同一 id 暴力攻击</li>
<li>布隆过滤器，使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库</li>
</ul>
<h3 id="缓存击穿">缓存击穿</h3>
<p>缓存中没有单数据库中有的数据（一般指缓存时间到期），由于并发用户较多，同时读缓存没有读到数据，又到数据库去取数据，引起数据库压力瞬间增大</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>设施热点数据永远不过期</li>
<li>接口限流与熔断，降级。重要的接口做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中某些服务不可用的时候，进行熔断，失败快速返回机制</li>
<li>加互斥锁。</li>
</ul>
<h3 id="缓存雪崩">缓存雪崩</h3>
<p>大量热点 key 设置了相同的过期时间，导致在缓存的同一时刻全部失效，造成瞬时数据库的请求量大，压力骤增，引起雪崩，甚至导致数据库被打挂</p>
<p><strong>解决方案</strong></p>
<ul>
<li>过期时间打散。给缓存的过期时间加上一个随机值时间，使得每个 key 的过期时间分不开来，不集中在同一时刻失效</li>
<li>热点数据不过期</li>
<li>加互斥锁。按 key 维度加锁，对同一个 key，只允许一个线程去计算，其他线程原地阻塞等待第一个线程的计算结果，然后直接走缓存。</li>
</ul>
<h2 id="接口限流服务降级熔断">接口限流、服务降级、熔断</h2>
<h3 id="接口限流">接口限流</h3>
<p><strong>限流原因：</strong></p>
<ul>
<li>用户增长过快</li>
<li>热点事件（微博热搜）</li>
<li>爬虫</li>
<li>恶意刷单</li>
<li>对内的 RPC 服务来说，一个接口可能被多个服务调用，一个服务突发流量把接口挂掉，导致其他服务也停止</li>
</ul>
<p><strong>单机限流算法</strong></p>
<ul>
<li>计数器算法</li>
<li>令牌桶</li>
<li>漏桶</li>
</ul>
<h4 id="计数器">计数器</h4>
<p>限制一秒钟能通过的请求数，每来一个请求将计数加一，达到阈值则后续请求全部拒绝</p>
<p><strong>弊端</strong>：突刺现象，可能前 10ms 通过阈值的请求，后面 990ms 只能把所有请求拒绝</p>
<h4 id="漏桶">漏桶</h4>
<p>**原理：**算法内部有一个容器，类似漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。如果容器满了，那么新进来的请求就丢弃。</p>
<p>**实现：**准备一个队列保存请求，通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行</p>
<p><strong>弊端</strong>：无法应对短时间突发流量。</p>
<h4 id="令牌桶">令牌桶</h4>
<p>**原理：**存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌，如果桶中令牌数达到上限，就丢弃令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。</p>
<img src="index/20200402211011246.png" style="zoom:60%;" />
<p>漏桶算法 能够强行限制数据的传输速率，而“令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输。在“令牌桶算法”中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，所以它适合于具有突发特性的流量。</p>
<h3 id="服务降级">服务降级</h3>
<p>系统将某些服务或者接口的功能降低</p>
<ul>
<li>双十一，订单暂不允许修改收货地址</li>
<li>论坛只能看帖子不能发帖子</li>
<li>App 日志上传接口，停掉一段时间，不能上传日志</li>
</ul>
<h3 id="熔断">熔断</h3>
<p>目的是应对依赖的外部系统故障的情况</p>
<ul>
<li>A 服务的 X 功能依赖 B 服务的某个接口，当 B 服务的接口相应很慢时，A 服务的 X 功能相应被拖慢，导致 A 服务的线程被卡在 X 功能处理上</li>
<li>加入熔断机制，A 服务不再请求 B 服务的这个接口，A 服务内部只要发现是请求 B 服务的这个接口就立即返回错误，避免 A 服务整个被拖慢</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li>统一的 API 调用层，由 API 调用层来进行采样或统计，如果接口调用散落在代码各处则无法进行统一处理</li>
<li>阈值设计，如1 分钟内 30% 请求响应时间超过 1s 接熔断</li>
</ul>


                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2023/02/27/cpp/specification/" data-toggle="tooltip" data-placement="top" title="一些 c&#43;&#43; 规范">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/fileSystem/" data-toggle="tooltip" data-placement="top" title="linux 文件系统">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

                



            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        <a href="/tags/cgroup" title="cgroup">
                            cgroup
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    </div>
                </section>
                

                
                
                <section>
                    <hr>
                    <h5>FRIENDS</h5>
                    <ul class="list-inline">
                        
                        <li><a target="_blank" href="https://gitee.com/icecream-jy">OwnDawn 的 gitee</a></li>
                        
                        <li><a target="_blank" href="https://github.com/IceCream-jy">OwnDawn 的 github</a></li>
                        
                    </ul>
                </section>
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:youremail@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    <li>
                        <a target="_blank" href="/your%20wechat%20qr%20code%20image">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-weixin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    <li>
                        <a target="_blank" href="https://github.com/yourgithub">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    <li>
                        <a target="_blank" href="https://www.linkedin.com/in/yourlinkedinid">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    <li>
                        <a target="_blank" href="https://stackoverflow.com/users/yourstackoverflowid">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
            
            
            
           
                   <li>
                       <a href='' rel="alternate" type="application/rss+xml" title="Owl Dawn" >
                           <span class="fa-stack fa-lg">
                               <i class="fas fa-circle fa-stack-2x"></i>
                               <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
            
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; Owl Dawn 2023
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>






<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>






</body>
</html>
