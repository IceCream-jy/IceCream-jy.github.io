<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="Owl Dawn">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="/img/amiya.jpg">
    <meta property="twitter:image" content="/img/amiya.jpg" />
    

    
    <meta name="title" content="redis" />
    <meta property="og:title" content="redis" />
    <meta property="twitter:title" content="redis" />
    

    
    <meta name="description" content="OwlDawn，程序员, 动漫爱好者 | 这里是 OwlDawn 的博客，与你一起发现更大的世界。">
    <meta property="og:description" content="OwlDawn，程序员, 动漫爱好者 | 这里是 OwlDawn 的博客，与你一起发现更大的世界。" />
    <meta property="twitter:description" content="OwlDawn，程序员, 动漫爱好者 | 这里是 OwlDawn 的博客，与你一起发现更大的世界。" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="OwlDawn, OwlDawn的博客, 个人网站, 互联网, Web, 云原生, Kubernetes, 微服务, Microservice">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>redis | OwlDawn的博客 | OwlDawn Blog</title>

    <link rel="canonical" href="/redis/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link href="https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css" rel="stylesheet" type="text/css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="/js/lazysizes.min.js"></script>

    
    

</head>






<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Owl Dawn</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                        <li>
                            <a href="/categories/ceph">ceph</a>
                        </li>
                        
                        <li>
                            <a href="/categories/cgroup">cgroup</a>
                        </li>
                        
                        <li>
                            <a href="/categories/coroutine">coroutine</a>
                        </li>
                        
                        <li>
                            <a href="/categories/cpp">cpp</a>
                        </li>
                        
                        <li>
                            <a href="/categories/leveldb">leveldb</a>
                        </li>
                        
                        <li>
                            <a href="/categories/linux">linux</a>
                        </li>
                        
                        <li>
                            <a href="/categories/raft">raft</a>
                        </li>
                        
                        <li>
                            <a href="/categories/redis">redis</a>
                        </li>
                        
                        <li>
                            <a href="/categories/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97">无锁队列</a>
                        </li>
                        
                    
                    
		    
                        <li><a href="/archive/">ARCHIVE</a></li>
                    
                        <li><a href="/notes/">NOTES</a></li>
                    
                        <li><a href="/about/">ABOUT</a></li>
                    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/amiya.jpg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/redis" title="redis">
                            redis
                        </a>
                        
                    </div>
                    <h1>redis</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                OwlDawn
                             
                            on 
                            Monday, February 27, 2023
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h1 id="redis_note">Redis_note</h1>
<p>6.0.9 版本源码</p>
<h2 id="数据结构">数据结构</h2>
<h3 id="sds">SDS</h3>
<p><strong>定义结构：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">__attribute__</span> ((__packed__)) sdshdr64 {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">uint64_t</span> len; <span style="color:#6272a4">/* used 已使用的字节长度 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">uint64_t</span> alloc; <span style="color:#6272a4">/* excluding the header and null terminator */</span><span style="color:#6272a4">//不包括头部和&#39;\0&#39;截止符
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> flags; <span style="color:#6272a4">/* 3 lsb of type, 5 unused bits */</span> <span style="color:#6272a4">//只有前3位被使用，用作标志SDS_TYPE_64 或 32 或 16 等等
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//部分语言技巧
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>sds;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))		</span><span style="color:#6272a4">// 将char*转换为 sdshdr 结构，函数传参使用 char*,在函数内部通过这个宏转换为 sdshdr
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// T 为8，16，32，64的选择
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> flags <span style="color:#ff79c6">=</span> s[<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>]; <span style="color:#6272a4">// 可以取出 flag
</span></span></span></code></pre></div><p><strong>字符串扩展内存不够时，分配策略：</strong></p>
<p>修改长度后，如果长度 len 小于 1M，将分配相同 len 的未使用空间，否则分配1M的未使用空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">#define SDS_MAX_PREALLOC (1024*1024)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>newlen <span style="color:#ff79c6">=</span> (len<span style="color:#ff79c6">+</span>addlen);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">if</span> (newlen <span style="color:#ff79c6">&lt;</span> SDS_MAX_PREALLOC)
</span></span><span style="display:flex;"><span>    newlen <span style="color:#ff79c6">*=</span> <span style="color:#bd93f9">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">else</span>
</span></span><span style="display:flex;"><span>    newlen <span style="color:#ff79c6">+=</span> SDS_MAX_PREALLOC;
</span></span></code></pre></div><p>缩短字符串后不会释放空间。</p>
<h3 id="链表">链表</h3>
<p>结构定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> listNode {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> listNode <span style="color:#ff79c6">*</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> listNode <span style="color:#ff79c6">*</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>value;
</span></span><span style="display:flex;"><span>} listNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> listIter {                <span style="color:#6272a4">// 迭代器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    listNode <span style="color:#ff79c6">*</span>next;                      <span style="color:#6272a4">// 当前迭代到的节点
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> direction;                       <span style="color:#6272a4">// 迭代方向
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} listIter;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> list {
</span></span><span style="display:flex;"><span>    listNode <span style="color:#ff79c6">*</span>head;
</span></span><span style="display:flex;"><span>    listNode <span style="color:#ff79c6">*</span>tail;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>dup)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>ptr);              <span style="color:#6272a4">// 节点值复制函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>free)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>ptr);              <span style="color:#6272a4">// 节点值释放函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>match)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>ptr, <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key);   <span style="color:#6272a4">// 节点值对比函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> len;                    <span style="color:#6272a4">// 节点数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} list;
</span></span></code></pre></div><h3 id="字典">字典</h3>
<p><strong>哈希表结构定义：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">/* This is our hash table structure. Every dictionary has two of this as we
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"> * implement incremental rehashing, for the old to the new table. */</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> dictht {
</span></span><span style="display:flex;"><span>    dictEntry <span style="color:#ff79c6">**</span>table;                  <span style="color:#6272a4">// 哈希表数组
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> size;                 <span style="color:#6272a4">// 哈希表大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> sizemask;             <span style="color:#6272a4">// 哈希表掩码，用于计算索引值，为 size - 1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> used;                 <span style="color:#6272a4">// 该哈希表已有节点的数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} dictht;
</span></span></code></pre></div><p>每个字典都使用两个哈希表，从而实现渐进式 rehash</p>
<p><strong>哈希表节点</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> dictEntry {              <span style="color:#6272a4">// 哈希表节点
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key;                          <span style="color:#6272a4">// 键
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">union</span> {                             <span style="color:#6272a4">// 值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>val;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">uint64_t</span> u64;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">int64_t</span> s64;
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">double</span> d;
</span></span><span style="display:flex;"><span>    } v;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> dictEntry <span style="color:#ff79c6">*</span>next;      <span style="color:#6272a4">// 指向下一个哈希表节点，形成链表
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} dictEntry;
</span></span></code></pre></div><p><strong>字典结构定义：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> dict {
</span></span><span style="display:flex;"><span>    dictType <span style="color:#ff79c6">*</span>type;             <span style="color:#6272a4">// 类型特定函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata;             <span style="color:#6272a4">// 私有数据
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    dictht ht[<span style="color:#bd93f9">2</span>];               <span style="color:#6272a4">// 哈希表
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">long</span> rehashidx;     <span style="color:#6272a4">/* rehash索引，rehash不在进行时为-1 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> iterators; <span style="color:#6272a4">/* 目前正在运行的安全迭代器的数量 */</span>
</span></span><span style="display:flex;"><span>} dict;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> dictType {          <span style="color:#6272a4">// 字典类型特定函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">uint64_t</span> (<span style="color:#ff79c6">*</span>hashFunction)(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key);          <span style="color:#6272a4">// 计算哈希值的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>keyDup)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key);   <span style="color:#6272a4">// 复制键的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">*</span>valDup)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>obj);   <span style="color:#6272a4">// 复制值的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>keyCompare)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key1, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key2);  <span style="color:#6272a4">// 对比键的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>keyDestructor)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata, <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>key);   <span style="color:#6272a4">// 销毁键的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>valDestructor)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>privdata, <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>obj);   <span style="color:#6272a4">// 销毁值的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} dictType;
</span></span></code></pre></div><p><code>ht[1]</code>哈希表只会在<code>ht[0]</code>哈希表进行 rehash 时使用</p>
<p><strong>迭代器结构：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">/* If safe is set to 1 this is a safe iterator, that means, you can call
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"> * dictAdd, dictFind, and other functions against the dictionary even while
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"> * iterating. Otherwise it is a non safe iterator, and only dictNext()
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"> * should be called while iterating. */</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> dictIterator {
</span></span><span style="display:flex;"><span>    dict <span style="color:#ff79c6">*</span>d;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">long</span> index;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> table, safe;
</span></span><span style="display:flex;"><span>    dictEntry <span style="color:#ff79c6">*</span>entry, <span style="color:#ff79c6">*</span>nextEntry;
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">/* unsafe iterator fingerprint for misuse detection. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">long</span> <span style="color:#8be9fd">long</span> fingerprint;
</span></span><span style="display:flex;"><span>} dictIterator;
</span></span></code></pre></div><p>语言技巧</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">#define dictSetVal(d, entry, _val_) do { \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">    if ((d)-&gt;type-&gt;valDup) \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">        (entry)-&gt;v.val = (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">    else \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">        (entry)-&gt;v.val = (_val_); \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">} while(0)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span><span style="color:#6272a4">// 使用 do{}while(0) 避免宏替换后代码被展开
</span></span></span></code></pre></div><p><strong>哈希算法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>hash <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">dictHashKey</span>(d,key);
</span></span><span style="display:flex;"><span>idx <span style="color:#ff79c6">=</span> hash <span style="color:#ff79c6">&amp;</span> d<span style="color:#ff79c6">-&gt;</span>ht[table].sizemask;  <span style="color:#6272a4">// 相当于 hash % size，将 hash 分布到 size 大小
</span></span></span></code></pre></div><p><strong>rehash</strong></p>
<ol>
<li>为<code>ht[1]</code>分配空间
<ul>
<li>扩展：大小为第一个大于等于 <code>ht[0].used * 2</code>的 2 的 n 次幂</li>
<li>收缩：大小为第一个大于等于 <code>ht[0].used</code>的 2 的 n 次幂</li>
</ul>
</li>
<li>将<code>ht[0]</code>包含的键值对 rehash 到 <code>ht[1]</code>上（重新计算哈希值与索引值）</li>
<li>释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新建一个空的哈希表</li>
</ol>
<p><strong>渐进式rehash</strong></p>
<p>将<code>rehashidx</code>设置为0，表示 rehash 开始</p>
<p>每次对字典执行操作时，程序会顺带将<code>ht[0]</code>在<code>rehashidx</code>上的键值对 rehash 到<code>ht[1]</code>，完成后+1</p>
<p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。例如查找某个键，程序会先在ht[0]中查找，如果找不到，就再去ht[1]中查找。</p>
<h3 id="整数集合">整数集合</h3>
<p>当一个集合<strong>只包含整数值元素</strong>，且这个集合的元素<strong>数目不多</strong>时，就会使用整数集合作为集合键的底层实现</p>
<p><strong>结构定义：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> intset {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">uint32_t</span> encoding;  <span style="color:#6272a4">// 编码方式
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">uint32_t</span> length;    <span style="color:#6272a4">// 集合包含的元素数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int8_t</span> contents[];  <span style="color:#6272a4">// 保存元素的数组，真正类型取决于 encoding 的值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} intset;
</span></span></code></pre></div><p><strong>升级：</strong></p>
<p>如 当向一个底层为 int16_t 数组的整数集合添加一个 int64_t 类型的整数值时，整数集合已有的所有元素都会转型为 int64_t 。</p>
<ol>
<li>重新分配空间</li>
<li>转换旧元素类型，放在正确位置上</li>
<li>添加新元素</li>
</ol>
<p><strong>不支持降级</strong></p>
<h3 id="压缩列表">压缩列表</h3>
<p><strong>储存结构：</strong></p>
<p><code>&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td></td>
<td>记录整个压缩列表占用字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td></td>
<td>记录压缩列表尾节点距离压缩列表起始地址有多少字节</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td></td>
<td>记录压缩列表包含的节点数量<!-- raw HTML omitted -->When there are more than 2^16-2 entries, this value is set to 2^16-1 and we need to traverse the entire list to know how many items it holds.</td>
</tr>
<tr>
<td>entry</td>
<td></td>
<td></td>
<td>节点</td>
</tr>
<tr>
<td>zlend</td>
<td></td>
<td></td>
<td>特殊值 0xFF 标记压缩列表的末端</td>
</tr>
</tbody>
</table>
<p><strong>entry</strong>:</p>
<p><code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></p>
<p><strong>prevlen:</strong></p>
<p>记录压缩列表前一个节点长度</p>
<p>见书</p>
<p><strong>连锁更新</strong></p>
<p>由于在插入长节点，使<code>prevlen</code>增加长度，从而引发的连锁更新</p>
<p>删除节点也会引发连锁更新</p>
<h3 id="quicklist">QuickList</h3>
<p>
  <img src="pic/20170418155917948.png" alt="">

</p>
<p><strong>结构定义</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> quicklist {
</span></span><span style="display:flex;"><span>    quicklistNode <span style="color:#ff79c6">*</span>head;
</span></span><span style="display:flex;"><span>    quicklistNode <span style="color:#ff79c6">*</span>tail;
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//ziplist中的entry节点计数器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> count;        <span style="color:#6272a4">/* total count of all entries in all ziplists */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//quicklist的quicklistNode节点计数器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span> len;          <span style="color:#6272a4">/* number of quicklistNodes */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 保存ziplist的大小，配置文件设定，占16bits
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">fill</span> : QL_FILL_BITS;              <span style="color:#6272a4">/* fill factor for individual nodes */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//保存压缩程度值，配置文件设定，占16bits，0表示不压缩
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">compress</span> : QL_COMP_BITS; <span style="color:#6272a4">/* depth of end nodes not to compress;0=off */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">bookmark_count</span>: QL_BM_BITS;
</span></span><span style="display:flex;"><span>    quicklistBookmark bookmarks[];
</span></span><span style="display:flex;"><span>} quicklist;
</span></span></code></pre></div><p><strong>quicklist节点结构</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> quicklistNode {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> quicklistNode <span style="color:#ff79c6">*</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">struct</span> quicklistNode <span style="color:#ff79c6">*</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//不设置压缩数据参数recompress时指向一个ziplist结构
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//设置压缩数据参数recompress指向quicklistLZF结构
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>zl;
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//压缩列表ziplist的总长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> sz;             <span style="color:#6272a4">/* ziplist size in bytes */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//ziplist中包的节点数，占16 bits长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">count</span> : <span style="color:#bd93f9">16</span>;     <span style="color:#6272a4">/* count of items in ziplist */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//表示是否采用了LZF压缩算法压缩quicklist节点，1表示压缩过，2表示没压缩，占2 bits长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">encoding</span> : <span style="color:#bd93f9">2</span>;   <span style="color:#6272a4">/* RAW==1 or LZF==2 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//表示一个quicklistNode节点是否采用ziplist结构保存数据，2表示压缩了，1表示没压缩，默认是2，占2bits长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">container</span> : <span style="color:#bd93f9">2</span>;  <span style="color:#6272a4">/* NONE==1 or ZIPLIST==2 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//标记quicklist节点的ziplist之前是否被解压缩过，占1bit长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//如果recompress为1，则等待被再次压缩
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">recompress</span> : <span style="color:#bd93f9">1</span>; <span style="color:#6272a4">/* was this node previous compressed? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//测试时使用
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">attempted_compress</span> : <span style="color:#bd93f9">1</span>; <span style="color:#6272a4">/* node can&#39;t compress; too small */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//额外扩展位，占10bits长度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">extra</span> : <span style="color:#bd93f9">10</span>; <span style="color:#6272a4">/* more bits to steal for future usage */</span>
</span></span><span style="display:flex;"><span>} quicklistNode;
</span></span></code></pre></div><p><strong>压缩过的ziplist结构—quicklistLZF</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> quicklistLZF {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//表示被LZF算法压缩后的ziplist的大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> sz; <span style="color:#6272a4">/* LZF size in bytes*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//保存压缩后的ziplist的数组，柔性数组
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">char</span> compressed[];
</span></span><span style="display:flex;"><span>} quicklistLZF;
</span></span></code></pre></div><p><strong>管理ziplist信息的结构quicklistEntry</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">//管理quicklist中quicklistNode节点中ziplist信息的结构
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> quicklistEntry {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> quicklist <span style="color:#ff79c6">*</span>quicklist;   <span style="color:#6272a4">//指向所属的quicklist的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    quicklistNode <span style="color:#ff79c6">*</span>node;          <span style="color:#6272a4">//指向所属的quicklistNode节点的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>zi;            <span style="color:#6272a4">//指向当前ziplist结构的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>value;         <span style="color:#6272a4">//指向当前ziplist结构的字符串vlaue成员
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">long</span> <span style="color:#8be9fd">long</span> longval;            <span style="color:#6272a4">//指向当前ziplist结构的整数value成员
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> sz;              <span style="color:#6272a4">//保存当前ziplist结构的字节数大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> offset;                   <span style="color:#6272a4">//保存相对ziplist的偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} quicklistEntry;
</span></span></code></pre></div><p><strong>迭代器</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">//quicklist的迭代器结构
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> quicklistIter {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> quicklist <span style="color:#ff79c6">*</span>quicklist;   <span style="color:#6272a4">//指向所属的quicklist的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    quicklistNode <span style="color:#ff79c6">*</span>current;       <span style="color:#6272a4">//指向当前迭代的quicklist节点的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>zi;            <span style="color:#6272a4">//指向当前quicklist节点中迭代的ziplist
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">long</span> offset;                  <span style="color:#6272a4">//当前ziplist结构中的偏移量      /* offset in current ziplist */
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> direction;                <span style="color:#6272a4">//迭代方向
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} quicklistIter;
</span></span></code></pre></div><p><strong>压缩深度</strong></p>
<p>quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数list-compress-depth决定。</p>
<p>为了支持快速的 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。</p>
<p>如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p>
<p><strong>插入</strong></p>
<p>以选择在头部或者尾部进行插入( <code>quicklistPushHead</code> 和 <code>quicklistPushTail </code>)，而不管是在头部还是尾部插入数据，都包含两种情况：</p>
<ul>
<li>如果头节点（或尾节点）上ziplist大小没有超过限制（即 <code>_quicklistNodeAllowInsert</code> 返回1），那么新数据被直接插入到ziplist中（调用<code>ziplistPush</code>）。</li>
<li>如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到 quicklist 双向链表中。</li>
</ul>
<p>也可以从任意指定的位置插入。<code>quicklistInsertAfter</code>和<code>quicklistInsertBefore</code>就是分别在指定位置后面和前面插入数据项。这种在任意指定位置插入数据的操作，要比在头部和尾部的进行插入要复杂一些。</p>
<ul>
<li>当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；</li>
<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；</li>
<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。</li>
<li>对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。</li>
</ul>
<h2 id="对象">对象</h2>
<p>结构定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff79c6">#define LRU_BITS 24
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> redisObject {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd;font-style:italic">type</span>:<span style="color:#bd93f9">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd;font-style:italic">encoding</span>:<span style="color:#bd93f9">4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd;font-style:italic">lru</span>:LRU_BITS; <span style="color:#6272a4">/* LRU time (relative to global lru_clock) or
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">                            * LFU data (least significant 8 bits frequency
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">                            * and most significant 16 bits access time). */</span>
</span></span><span style="display:flex;"><span>                           <span style="color:#6272a4">// 最后一次被命令访问时间
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> refcount;          <span style="color:#6272a4">// 引用计数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>ptr;             <span style="color:#6272a4">// 指向底层实现数据结构
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} robj;
</span></span></code></pre></div><h4 id="字符串对象">字符串对象</h4>
<ul>
<li>
<p>int</p>
</li>
<li>
<p>raw</p>
</li>
<li>
<p>embstr  <strong>只读</strong> 任何修改命令都将其转为raw</p>
<p>调用一次内存分配函数创建 redisObject 结构和 sdshdr 结构，只需一次内存分配次数和一次内存释放次数。</p>
<p>只读，任何修改命令将转换为raw</p>
</li>
</ul>
<h4 id="列表对象">列表对象</h4>
<p>redis3.2之后使用quicklist代替了ziplist和linkedlist</p>
<h4 id="哈希对象">哈希对象</h4>
<ul>
<li>
<p>ziplist</p>
<p>同一键值对的两个节点紧挨在一起，键在前，值在后，不同键值对按添加顺序排列</p>
</li>
<li>
<p>hashtable</p>
<p>对象的每个键值对都是用一个字典键值对来保存，每个键和每个值都是一个字符串对象</p>
</li>
</ul>
<h4 id="集合对象">集合对象</h4>
<p>只存储不重复元素，无序方式，而列表对象可存储重复元素，先后顺序</p>
<ul>
<li>
<p>intset</p>
<p>当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</p>
</li>
<li>
<p>hashtable</p>
</li>
</ul>
<h4 id="有序集合对象">有序集合对象</h4>
<p>相比于集合类型多了一个排序属性 score（分值）</p>
<ul>
<li>
<p>ziplist</p>
</li>
<li>
<p>skiplist</p>
<p>同时使用跳跃表和字典实现，字典根据键找分值快，跳跃表根据分值找键快</p>
</li>
</ul>
<h2 id="数据库">数据库</h2>
<p>服务区每个数据库都有redisDb结构表示，dict字典保存着数据库的所以键值对，每个<strong>键为字符串对象，值为任意Redis对象</strong></p>
<h4 id="过期键删除策略">过期键删除策略</h4>
<ul>
<li>
<p>定时删除 对内存友好，cpu不友好</p>
</li>
<li>
<p>惰性删除 对cpu友好，内存不友好</p>
</li>
<li>
<p>定期删除 折中</p>
<p>规定时间内，分多次遍历，随机检查一部分过期时间</p>
</li>
</ul>
<p><strong>RDB</strong></p>
<p>保存时，过期键不会保存入新创建的RDB文件中</p>
<ul>
<li>主服务器模式：启动载入时过期键会被忽略</li>
<li>从服务器模式：所有键都会载入，从服务器数据会被清空</li>
</ul>
<p><strong>AOF</strong></p>
<p>过期键被删除时AOF文件追加一条DEL命令</p>
<p>过期键不会保存到重写的AOF文件中</p>
<p>复制模式下，主服务器删除一个过期键，则同时通知从服务器删除，向从服务器发送DEL命令。</p>
<p>访问主服务器的过期键，会被删除，访问从服务器的过期键，能够访问</p>
<h4 id="rdb">RDB</h4>
<p>SAVE、BGSAVE</p>
<p>服务器启动时自动载入RDB文件。服务器优先使用AOF文件还原数据库状态，AOF关闭时才使用RDB</p>
<p>服务器载入RDB文件期间处于阻塞状态</p>
<h4 id="aof">AOF</h4>
<p>服务器appendfsync的值直接决定AOF持久化功能的效率和安全性</p>
<ul>
<li>always  最慢</li>
<li>everysec</li>
<li>no</li>
</ul>
<p><strong>AOF重写</strong></p>
<p>原理：首先从数据库读取现有键值，用一条命令记录键值，代替之前的多条冗余命令</p>
<p>使用==<strong>子进程</strong>==而非线程，这样重写期间，服务器进程（父进程）可以继续处理命令</p>
<p>完成后向父进程发送信号，将AOF重写缓冲区的内容写入新AOF缓冲区并替换</p>
<h4 id="事件">事件</h4>
<p><strong>文件事件</strong></p>
<p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p>
<p>
  <img src="pic/2.png" alt="">

</p>
<p><strong>时间事件</strong></p>
<p>所有时间事件都放在一个<strong>无序列表</strong>中</p>
<ul>
<li>定时事件</li>
<li>周期事件</li>
</ul>
<p>
  <img src="pic/1.png" alt="">

</p>
<p>对时间事件与文件事件的处理都是<strong>同步、有序、原子</strong>地执行，事件间不会抢占</p>
<h3 id="集群">集群</h3>
<p><code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 让 node 节点与 ip 和 port 指定的节点进行握手，握手成功时将指定的节点添加进当前所在集群</p>
<p><code>CLUSTER ADDSLOTS &lt;slot&gt; [slot ...]</code>将一个或多个槽给节点负责</p>
<p>当客户端向节点发送与数据库键有关的命令时，节点会计算键属于哪个槽，检查这个槽是否指派给自己，否则返回MOVED错误，指引客户端至正确节点，并重复步骤。</p>
<p><code>CLUSTER KEYSLOT &lt;key&gt;</code> 查看给定键属于哪个槽</p>
<p>重新分片操作可以在线进行，并可继续处理命令请求</p>


                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2023/02/27/cpp/specification/" data-toggle="tooltip" data-placement="top" title="一些 c&#43;&#43; 规范">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/fileSystem/" data-toggle="tooltip" data-placement="top" title="linux 文件系统">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

                



            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        <a href="/tags/cgroup" title="cgroup">
                            cgroup
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    </div>
                </section>
                

                
                
                <section>
                    <hr>
                    <h5>FRIENDS</h5>
                    <ul class="list-inline">
                        
                        <li><a target="_blank" href="https://gitee.com/icecream-jy">OwnDawn 的 gitee</a></li>
                        
                        <li><a target="_blank" href="https://github.com/IceCream-jy">OwnDawn 的 github</a></li>
                        
                    </ul>
                </section>
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:youremail@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    <li>
                        <a target="_blank" href="/your%20wechat%20qr%20code%20image">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-weixin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    <li>
                        <a target="_blank" href="https://github.com/yourgithub">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    <li>
                        <a target="_blank" href="https://www.linkedin.com/in/yourlinkedinid">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    <li>
                        <a target="_blank" href="https://stackoverflow.com/users/yourstackoverflowid">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
            
            
            
           
                   <li>
                       <a href='' rel="alternate" type="application/rss+xml" title="Owl Dawn" >
                           <span class="fa-stack fa-lg">
                               <i class="fas fa-circle fa-stack-2x"></i>
                               <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
            
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; Owl Dawn 2023
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>






<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>






</body>
</html>
